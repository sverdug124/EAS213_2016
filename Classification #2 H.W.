"+#read in data\n",
    " +import landsat as lf\n",
    " +rgbpath = \"data/landsat_RGBN.txt\" \n",
    " +rgbn = lf.landsat_read(rgbpath)\n",
    " +# extracts the file for rgbn\n",
    " +\n",
    def RGB_subset_2014-04-26-ac.png
    " +# compute the array at a given contrast\n",
    " +rgb_array = lf.rgb_contrast(rgbn[...,:3], 3)\n",
    " +\n",
    " +#use zoom to find region of interest\n",
    " +%matplotlib notebook\n",
    " +import matplotlib.pyplot as plt\n",
    " +\n",
    " +# plots the axis for the map\n",
    " +fig, ax = plt.subplots()\n",
    " +ax.imshow(rgb_array)\n",
    " +\n",
    " +# displays the size of the map\n",
    " +# xbounds: 260, 360\n",
    " +# ybounds: 260, 400\n",
    " +x1, x2 = 260, 360\n",
    " +y1, y2 = 260, 400\n",
    " +subset = rgb_array[x1:x2, y1:y2]\n",
    " +fig = plt.figure()\n",
    " +ax = fig.add_subplot(1,1,1)\n",
    " +ax.imshow(subset)\n",
    " +\n",
    " +# plot pdf of red in that region\n",
    " +# plots red in that region\n",
    " +red = subset[...,0]\n",
    " +\n",
    " +# displays statistics to commence probability \n",
    " +import scipy.stats as st\n",
    " +import numpy as np\n",
    " +\n",
    " +# porbability of each region\n",
    " +#estimate the P function of the distribution\n",
    " +kernal = st.gaussian_kde(red.flatten())\n",
    " +# color values range between 0 & 1 \n",
    " +x = np.linspace(0,1,100) #the range of potential color values\n",
    " +y = kernal(x) #probability of each x happening\n",
    " +\n",
    " +# plots the intensity and probability of the color\n",
    " +fig = plt.figure()\n",
    " +ax = fig.add_subplot(1,1,1)\n",
    " +ax.plot(x, y, color='red')\n",
    " +ax.set_xlabel(\"Intensity\")\n",
    " +ax.set_ylabel(\"Probability\")\n",
    " +\n",
    " +# now add the pdfs for green & blue\n",
    " +# adds the pdfs for green & blue\n",
    " +#unpack red, green, blue\n",
    " +red = rgb_array[...,0]\n",
    " +green = rgb_array[...,1]\n",
    " +blue = rgb_array[...,2]\n",
    " +\n",
    " +\n",
    " +#lets build an arbitrary blue mask\n",
    " +# displays range for blue and defines it\n",
    " +bmean = blue.mean()\n",
    " +print(bmean)\n",
    " +blue_mask = (blue>bmean)\n",
    " +print (blue_mask)\n",
    " +\n",
    " +import numpy as np\n",
    " +import matplotlib.cm as mcm\n",
    " +import matplotlib.colors as mcolors\n",
    " +#displays the colors in python \n",
    " +\n",
    " +# plot the map\n",
    " +cmap = mcm.bone\n",
    " +norm = mcolors.BoundaryNorm([0,1,2],cmap.N)\n",
    " +fig = plt.figure()\n",
    " +ax = fig.add_subplot(1,1,1)\n",
    " +im = ax.imshow(blue_mask, cmap=cmap, norm=norm)\n",
    " +cb = fig.colorbar(im, ax=ax)\n",
    " +cb.set_ticks([0.5,1.5])\n",
    " +cb.set_ticklabels([\"not in mask\",\"in mask\"])\n",
    " +fig.canvas.draw()\n",
    " +\n",
    " +#plot only the data shown in the map\n",
    " +rgb_copy = rgb_array.copy()\n",
    " +#zero out values not in mask\n",
    " +\n",
    " +# copy the blue mask\n",
    " +rgb_copy[~blue_mask] = np.nan\n",
    " +cmap = mcm.bone\n",
    " +norm = mcolors.BoundaryNorm([0,1,2],cmap.N)\n",
    " +fig = plt.figure()\n",
    " +# plot the figure\n",
    " +ax = fig.add_subplot(1,1,1)\n",
    " +im = ax.imshow(rgb_copy)\n",
    " +fig.canvas.draw()\n",
    " +\n",
    " +#compare data in mask to data not in mask:\n",
    " +class1 = rgb_array[blue_mask] # data in mask\n",
    " +class2 = rgb_array[~blue_mask] # data outside of mask\n",
    " +\n",
    " +# define the linespace \n",
    " +x = np.linspace(0,1,100) \n",
    " +def pdf(data):\n",
    " +    kernal = st.gaussian_kde(data.flatten())  \n",
    " +    y = kernal(x) \n",
    " +    return y\n",
    " +    \n",
    " +# define the colors\n",
    " +colors = ['red', 'green','blue']\n",
    " +fig = plt.figure()\n",
    " +ax = fig.add_subplot(1,1,1)\n",
    " +ax.set_title(\"class 1\")\n",
    " +for i, c in enumerate(colors):\n",
    " +    ax.plot(x, pdf(class1[i]), color=c, label=\"class 1\")\n",
    " +    ax.plot(x, pdf(class2[i]), color=c, linestyle='--', label='class 2')\n",
    " +\n",
    " +ax.legend()\n",
    " +\n",
    " +#combines masks and shows which region is in both\n",
    " +blue_mask = (blue>blue.mean())\n",
    " +red_mask = (red>red.mean())\n",
    " +comb_mask = (blue_mask & red_mask)\n",
    " +\n",
    " +# displays the map and it's boundary \n",
    " +cmap = mcm.bone\n",
    " +norm = mcolors.BoundaryNorm([0,1,2],cmap.N)\n",
    " +fig = plt.figure()\n",
    " +ax = fig.add_subplot(1,1,1)\n",
    " +im = ax.imshow(comb_mask, cmap=cmap, norm=norm)\n",
    " +cb = fig.colorbar(im, ax=ax)\n",
    " +cb.set_ticks([0.5,1.5])\n",
    " +cb.set_ticklabels([\"not in mask\",\"in mask\"])\n",
    " +fig.canvas.draw()\n"
    " +# It was a not a good classifier because it did not clearly emphazise the specified region.
       # The classifier was supposed to highlight a region based on the inputed image, but it failed to do that
       # because the appropriate mask needed to execute the classifier was not used. 
